//your go to js notes
//vvv brief
//there is an execution context in js where there are 2 components: memory and code.
//memory aka variable environment stores data in key value pairs
//code component aka thread of execution executes one line at a time (single thread)

//*****js is synchronous single threaded language******

//in js, unlike other languages there are two phases of this execution context
//first (memory creation phase) skimming is done to allocate memory to every element (top to down)
//second (code execution phase) we start main execution (top to down)

// in functions an altogether new ec is created and in phase 1 we allocate mem to parameters as well as variables inside the function
//CODE:
var n = 2;
function square(num) {
  var ans = num*num;
  return ans;
}

var square2 = square(n);
var square4 = square(4);

// first of all global execution context is created
//phase 1:
//line 15 n is allocated undefined
//line 16 square is allocated {.....} whole code inside of it
//line 21 square2 is allocated undefined
//line 22 square4 is allocated undefined
//phase 2:
//line 14 in n value undef replaced with 2
//line 20 (we have function call) 
    //local ec of function created where only code inside func square is dealt with
    //phase 1:
    //line 15 num is allocated undef
    //line 16 ans allocated undef
    //phase 2:
    //line 21 function invoked with arg n and we have n = 2 from gec, hence in lec we replace undef with 2 for num
    //line 17 now ans = num*num = 4 and ans's undef replaced with 4
    //line 18 special keyword ans... now return the control to place where function was invoked now line 21 square2 will get val of ans = 4
    //line 21 in global ec we will now replace square2 with 4 which was returned.
//since function is over, whole lec is deleted now
//line 22 (we have func call)
    //local ec of function created where only code inside func square is dealt with
    //phase 1:
    //line 15 num is allocated undef
    //line 16 ans allocated undef
    //phase 2:
    //line 22 function invoked with arg 4, hence in lec we replace undef with 4 for num
    //line 17 now ans = num*num = 16 and ans's undef replaced with 16
    //line 18 special keyword ans... now return the control to place where function was invoked now line 21 square4 will get val of ans = 16
    //line 22 in global ec we will now replace square4 with 16 which was returned.
//since function is over, whole lec is deleted now
//since whole code complete we will delete gec now

//CALL STACK: it maintains the order of execution of execution contexts.
//in above example, first stack had 
//$
//$->gec
//$->gec->lec(line 21)
//$->gec
//$->gec->lec(line 22)
//$->gec
//$

//HOISTING IN JS:
// 1. Hoisting in JavaScript is a process in which all the Variables, Functions and Class defination are declared BEFORE execution of the code 
// 3. Variables are initialised to UNDEFINED when they are declared and Function defination is stored AS IT IS.
// 4. They are declared in Memory Allocation Phase in the Memory Component of Execution Context, so we can use them even BEFORE they are declared.
// 5. UNDEFINED means Variable has been declared but value is not ASSIGNED but NOT DEFINED means Variables is NOT DECLARED.
// 6. When we assign Variable to a Function definItion(like arrow function), we CAN NOT call this Variable as Function BEFORE declaration as it will behave as Variable with UNDEFINED value.
//take eg:

getName();
console.log(x);

var x = 7;
function getName() {
  console.log("Namaste javascript");
}

//in any other language above code will give error since nothing is defined initially
// but in js op will be:
Namaste javascript
undefined

//why? its because there are two phases of ec! in first phase we allocate memory to all variables and functions
// thus in second phase when code is actually executed.. we do have the elements in our variable environment.
// function executes normally
// however line 71, we dont have x initialsed to anything yet thus it prints its placeholder value i.e. undefined
//wow right?

// just btw 
  console.log(getName)
//this will give output on console:
f getName() {
  console.log("Namaste javascript");
}
//now : 

getName();
console.log(x);
console.log(getName)
  
var x = 7;
function getName() {
  console.log("Namaste javascript");
}

//output will be:
Namaste javascript
undefined
f getName() {
  console.log("Namaste javascript");
}

// it is self explanatory by now (since in first phase line 74, will store getName : {......} code of the entire function in memory)
//EVEN BEFORE CODE STARTS EXECUTING, WE ALREADY ALLOCATE MEMORY TO VARIABLES AND FUNCTIONS, this is called HOISTING

//one more imp thing: arrow function
var getName = () => {
  console.log("Namaste javascript");
}

//js treats arrow functions as variables only. now if we run getName() in the code (before the function definition) where getName is an arrow function, console will give error saying getName is not a funciton
// arrow function is also allocated undefined (cuz treated as var)
//another method shown below also behaves as var
var getName2 = function () {

}

//SHORTEST JS PROGRAM:

// an empty file is still a shortest code as a global execution context is created and sets up memory space

	// • window object is created by the JS engines of the respective browsers when global execution context is created.
	// • whenever an execution context is created a "this" variable is also created.
	// • at the global level "this" points to the global object( window object in case of browsers).
	// • anything that is not inside a function is the "global space".
	// • whenever we create any variables or functions in the "global space", they get attached to the global object( window object in case of browsers).
	
	// so to access the variables/function defined in the global space , 

var a = 10;

	// we can use any of the below:
	// 	console.log(window.a);
	// 	console.log(a);
	// 	console.log(this.a)             //at the global space level, where this points to the window object
//op will be:
10
10
10

//Undefined is like a placeholder for an allocated memory till a value is assigned to a variable.
//undefined !== not defined
//js is a loosely typed or weakly typed language doesnt attach data type to a var forever..
// if u use var x as a string then later can use it as bool, int etc. anything

//SCOPE CHAIN AND LEXICAL ENVIRONMENT
  
// 0) Lexical environment = EC's Local Memory + Reference to Lexical Environment of its parent.

// 1) Lexical Environment of its parent is the scope where a function is physically present or defined. So, suppose a function x(), is defined and invoked in the GEC, when function x()'s EC is pushed in the call stack, it stores a reference to its parent's lexical environment i.e. the GEC's memory.

// 2) Whenever a new Execution Context is pushed in the Call Stack it holds a reference to the Lexical Environment of its parent, i.e. the EC's memory from where it was invoked.

// 3) Global execution context holds reference to null.

// 4)  Javascript engine first looks for the variable/function being accessed in the local scope of the function, and if not found, it keeps on searching the lexical environment of its parent until it finds the variable/function being accessed.

// 5) The mechanism mentioned in point 4 above is called SCOPE CHAIN.

// 6) If the variable accessed is not found in the Scope Chain, then you will get the variable is not defined error in the  browser's console.

//LET AND CONST, TEMPORAL DEAD ZONE

// 1. let and const are hoisted but its memory is allocated at other place than window which cannot be accessed before initialisation. (eg: Script)
// 2. Temporal Dead Zone is the block of code where a variable is inaccessible until variable is declared and initialised a value.
  console.log(a);
  var b = 9;
  let a = 90;
// for a, the TDZ is lines 180 and 181. this on running gives reference error at 180 because, the let a is not allocated in global memory

// 3. window.variable OR this.variable will not give value of variable defined using let or const. because let and const memory is not allocated in global scope but somewhere else
// 4. const variable declaration and initialisation must be done on the same line.
// 5. strictness var<<let<<const
    var //no temporal dead zone, can redeclare and re-initialize, stored in GES
    let //use TDZ, can't re-declare, can re-initialize, stored in separate memory
    const //use TDZ, can't re-declare, can't re-initialize, stored in separate memory
// 6. There are three types of error: [1] referenceError {given where variable does not have memory allocation} [2] typeError {given when we change type that is not supposed to be changed, eg reinitalize const} [3] syntaxError {when proper syntax(way of writing a statement) is not used}.
// 7. Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.
// 8. Initialising variables at the top is good idea, helps shrinks TDZ to zero.

//BLOCK SCOPE AND SHADOWING
//Q) What is block in JavaScript?
// multiple js statements formed in a group enclosed in brackets and it forms a block

//Q) What is need of a block/Grouping?
//JavaScript sometimes expect to run a single statement to run, but we need to run commands with multiple statements which is only possible by block

//write a simple function:
// even empty script is perfectly valid js script, what about empty brackets!!
{
 var a = 10;
 let b = 20;
 const c =30; 
}

//When a js script get hoisted (a Global Execution Context) gets created 'var' listed towards 'Global environment' and other variables 'let' and 'const' declarations go to the 'Block environment' 

//This become especially important when deciding the scope of a particular variable, since b and c are located in 'Block environment' and for a as we know exists in 'Global environment' any statement out of the "Block" can access 'a' ie.  ' Variable in Global environment' and other are not!

//so when we understand the extent of Global and local environment variables and their 'Scopes' == Environment that forms the lexical hierarchy of 'Scopes' and 'Scopes' have Levels like 'Scope inside scope'


 var a = 100;
{
 var a = 10;
 let b = 20;
 const c =30; 
 console.log(a);
 console.log(b);
 console.log(c);
}
 console.log(a);
 console.log(b);
 console.log(c);

//OP:
10
20
30
10
error
//So in block " var a = 10;" influences the global value itself because var is hoisted in global space, hence  console.log(a); >> 10 and outside of the block 'Variable in Global environment' influences value of a hence console.log(a); >> 10

//SHADOWING: basically when a variable of same name is declared inside a scope, it is now relevant within the scope as the locally declared variable. this is called shadowing as it shadows the original outer scope variable.


let a = 20;
{
  let a = 10;
  console.log(a);
}
console.log(a);
//OP:
10
20

//a shadows global a inside the scope.
//(but if it was var, there would be shadowing however, after coming out of scope, the variable will not regain global value as it has been modified by local var cuz they share same memory space.. thus var is not block scoped

//ILLEGAL shadowing:

let a = 200;
{
 var a =20;
}

//as 'var' declaration goes to 'Global environment' and sets in Memory context, it cannot be set using 'Block environment' value Hence:    Uncaught SyntaxError: Identifier 'a' has already been declared
var a = 20;
{
 let a = 25;
}

// this is acceptable as let is block scoped and a is an independent variable allocated in a different space (block space) unlike var which is allocated in global space.

//CLOSURE:
//closure :Function bundled with its lexical environment is known as a closure. 
// a function remembers its outer environment as it stores a reference of its outer env even if it is executed elsewhere. outer env includes variables declared outside the function be it let, var ,const anyting, or a parameter passed in an outer nested function..
// Whenever function is returned, even if its vanished in execution context but still it remembers the reference it was pointing to. 
// Its not just that function alone it returns but the entire closure and that's where it becomes interesting !! 

// in js functions can be assigned to variables, fn can be passed as parameters, fn can be returned from other fn as well.

function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 return y;
}
var z = x(); // after this line executes, x will be gone (x's lec will be deleted) and variable z will be assigned return val of x() (basically z stores closure of return val of x i.e function "y" and it still remembers the reference it was pointing to ) in a way z is also a function 
console.log(z); // here the content of z is printed. what is z? simply the returned value of x() i.e. function y. so output will be the code of function y
z(); //(interesting) we call z and it holds function y which has a reference to 'a' thus z stores the closure of y 

//OP:
f y(){
  console.log(a);
}
7 //because z contains closure of y which means memory and the lexical env of y hence a is preserved
//also
function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 return y;
}

//same as

function x(){
 var a = 7;
 return function y(){
    console.log(a);
  }
}

//Q: what will be op?

function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 a = 100;
 return y;
}
var z = x();
z();

//OP:
100
// calling z means calling y (as z = ret val of x = y). now y does not store the "value" of a but the "reference" of a. 
// hence when we modify a as 100, we have affected the reference in the lexical env. thus we get op as 100

//Q: what will be op?

function z() {
 var b = 900;
 function x(){
    var a = 7;
    function y(){
       console.log(a,b); // when we are here during execution, fn y stores closure of x which inturn stores closure of z. thus we have both references a and b in hand.
     }
    y();
   }
 x();
}
z();

//OP: 7 900

//SET-TIMEOUT
//1. setTimeout stores the function in a different place and attached a timer to it, when the timer is finished it rejoins the call stack and executed. (while executing in diff place, it obv has the closure of all variables which share scope with it)
//2. Without closure the var reference gives the latest value as it does not retain the original value but rather has the reference so any update in value after timeout will be shown.
//3. If we use let/const because they have block scope, every time a new copy of variable is attached, thus this can be done without closure.

function x(){
 var i = 1;
    setTimeout(function() {
      console.log(i);
     }, 3000); // means timeout of 3 seconds or 3000 mili sec
    console.log("hello");
}
x();

//OP:
hello
1 //after 3 sec
//note: see that hello didnt print after 3 sec as it might appear from code. this is cuz settimeout executes somewhere else, storing the closure in this case the reference to i,. the rest of code executes normally, and when settimeout is done executing, it joins back in the call stack. 
// thus hello prints as usual but 1 is printed after a timeout of 3 seconds.

// explanation of pt 2 with situation: say u have to print numbers 1 2 3 4 5 one after other in 1 sec gap

function x(){
 for(var i = 1;i<=5;i++) {
     setTimeout(function() {
       console.log(i);
      }, i*1000); 
   }
 console.log("hello");
}
x();

//OP:
hello
6
6
6
6
6
//after 1 sec gap each

//.....wHATTTTTT 
//hehe this is cuz setTimeout has the closure of its lexical env as in it still references  to 'i'. now loop will run in usual pace and i will quickly increment to 6. but in these seperate timeouts of 1000,2000,3000,4000,5000 ms we have i referencing to same memory location. thus they all will now have 6.
//upon printing also they all print 6 as and when their timer exhausts.

//fixing the problem by "let" as let as block scope. thus with each loop iteration, each function has a new copy of i which has independent space in their scope.

function x(){
 for(let i = 1;i<=5;i++) {
     setTimeout(function() {
       console.log(i);
      }, i*1000); 
   }
 console.log("hello");
}
x();

//OP:
hello
1
2
3
4
5

//what if u cant use let?

//u can use a function embedded inside our loop and pass i as a parameter. this will always create new copy of i 

function x(){
 for(var i = 1;i<=5;i++) {
   function close(x) {
      setTimeout(function() {
        console.log(x);
       }, x*1000); 
    }
   close(i);
  }

 console.log("hello");
}
x();

//OP:
hello
1
2
3
4
5

//code writing in js : random snippet

function Counter()
{
	var count = 0;

	this.incrementCounter = function(){
	  count++;
	  console.log(count);
	}
	
	this.decrementCounter = function(){
	  count--;
	  console.log(count);
	}
}

var counter1 = new Counter();

counter1.incrementCounter();

//*data hiding of variables like count in this case.. decrementCOunter and incrementCOunter are function constructors.. kinda see the OOD pattern here.

//Disadvantage of closure:
//overconsumption of memory, and sometimes variables not grabage collected after program is over and if not handles properly leads to memory leaks
//garbage collection: program in js engine which frees up the unutilised memory
//1. An inner function can be directly called using two parenthesis ()().
//2. Even parameters can be passed this way (Remember that the function needs to be returned to do this)
//3. Closures can also be used for data hiding and encapsulation. So other code cannot access this value.
//4. Unused variables are automatically deleted in High Level Programming language by garbage collector. Closures allocate a lot of memory which cannot be deleted so this acts as a disadvantage.
//5. Some browsers now have smart garbage collectors that automatically deletes variables that are not used outside closures.

// FUNCTIONS!
// 1.  What is Function Statement/Function Decleration ?
// A.  A normal function that we create using Naming convention. & By this we can do the Hoisting.
//      For Ex  -  

      function xyz(){
        console.log("Function Statement");
   }

// 2.  What is Function Expression ?
// A.  When we assign a function into a variable that is Function Expression. & We can not do Hoisting by this becz it acts like variable.
//       For Ex - 
var a = function(){
              console.log("Function Expression");
      }

//MAJOR DIFF BETWEEN func exp and func statement is that func statement will be hoisted even before execution. so calling it before exec is no prob.
//BUT func exp behaves like a variable.. initially allocated undefined. thus calling it before its definition will give typeError cuz its a var.

// 3.  What is Anonymous Function ?
// A.  A Function without the name is known as Anonymous Function. & It is used in a place where function are treated as value.
//       For Ex - 

function ()  {
   
 }
//normally it is invalid syntax but it comes in use when func is used as value


// 4.  What is Named Function Expression ?
// A.  A function with a name is known as Named Function Expression.
//       For Ex - 
var a = function xyx(){
            console.log("Names Function Expression");
      }
//NOTE: here
xyz();
// above will give reference error saying xyz not defined. why? 
// because xyz is not in global scope, it is within the local scope of var a thus we cannot access it from outside.


// 5.  Difference b/w Parameters and Arguments ?
// A.  When we creating a function  & put some variabels in this ( ) that is our Parameters.
//      For Ex - 
function ab( param1, param2 ){
        console.log("..");
}
//        & When we call this function & pass a variabel in this ( ) that is our Arguments
//        For Ex - 
ab( 4, 5 );


// 6.  What is First Class Function Or First class citizens?

// A.   The Ability of use function as value,

// *     Can be passed as an Argument,
//eg:

var b = function(param){
  console.log(param);
} 

   //EITHER
b(function(){
  console.log("hi");
});
   //OR
function xyz(){
  console.log("hi");
}

b(xyz)
   //will give

//OP:
f (){
  console.log("hi");
}

// *     Can be executed inside a closured function &
// *     Can be taken as return form.
//       For Ex - 
var b = function(param){
        return function xyz(){
                console.log(" F C F ");
        }
} 

console.log(b());

//OP:
function xyz(){
  console.log(" F C F ");
}


// 7. Function are heart of JS. They are called first class citizens or first class functions because they have the ability to be stored in the variables, passed as parameters and arguments. They can also be returned in the function.

//CALLBACK FUNCTIONS:
// 1. Function that is passed on as argument to another function is called callback function.
function x(){

}

x(function y(){

})
//y is the callback function

//consider:

setTimeout(function() {
  console.log("timer");
},5000); 

function x(y){
   console.log("x");
   y();
}

x(function y(){
  console.log("y");
})
//OP:
x//immediate
y//immediate
timer//after 5 secs
// 2. setTimeout helps us perform asynchronous operation(timer ticking elsewhere while rest of the code executes normally doesnt get blocked) evn tho js is single threaded synch lang as it only has one main thread and one call stack.
// 3. Event listeners can also invoke closures with scope.

document.getElementById("clickMe").addEventListener("click",function xyz(){
  console.log("button clicked");  //this right here is a function callback to xyz. and it will be pushed to the call stack everytime the eventlistener is executed. 
});

//how to show number of times clicked.
//use closure by wrapping inside a function
 
function attachEventListener() {
  let count = 0;

  document.getElementById("clickMe").addEventListener("click",function xyz(){
    console.log("button clicked",++count);  //this right here is a function callback to xyz. and it will be pushed to the call stack everytime the eventlistener is executed. 
  });

}

attachEventListener();

// 4. Event listeners consume a lot of memory which can potentially slow down the website therefore it is good practice to remove if it is not used.

//EVENT LOOOOOOOOP

// 1. Browser has superpowers that are lent to JS engine to execute some tasks, these superpowers include "web API's" such as console, location, DOM API, setTimeout, fetch, local storage.
// 2. Callback functions and event handers are first stored in Web API environment and then transferred to callback queue.

//eg:

console.log("start");

setTimeout(function cb() {
  console.log("Callback");
},5000);

console.log("End");

//first gec pushed to call stack start is printed..
//settimeout executes, call back function cb is stored in a Web API environment for the time being and timer starts running.
//meantime, end is printed.. gec is over so gec is pushed out call stack is empty
// now timer still running and hits 0 but now what? we need call back function to go to call stack.. we cant do it just like that

//concept of event loop and callback queue arrives.

//cb function is pushed to callback queue from the webapi env. 
//EVENT loop is like a gatekeeper, who keeps checking whether the callback queue is empty or not.. and if not, it pushes the func to call stack. then the call stack quickly executes cb function.. CAllback is printed.. cb is popped out of the stack. call back que empty. all over

//eg with eventlistener:

console.log("Start");

document.getElementById("btn").addEventListener("click", function cb(){
  console.log("callback");
}); //basically whenever we see addEventListener, it registers thr callback function(here cb) in the webAPI's environment and attaches a "click" evevnt to it

console.log("end");

//the callback function with the event is in the webapi env and is forever waiting for event to occur and then the func will be pushed to cb queue and then the event loop will push it to the stack for execution. thus eventlisteners are very heavy.

//There is one more queue called microstask queue. Event loop gives priority to microtask queue as compared to callback queue or task q.

//eg: 

console.log("Start");

setTimeout(function cb() {
  console.log("Callback settimeout");
},5000);

fetch("https://api.netflix.com").then(function cbF() {
  console.log("CB Netflix");
}); //will study later.. but fetch function returns a promise. fetch function goes and fetches the api call and returns the response after which 'then' is excecuted in this line

console.log("end");

// 3. Promises and mutation observer are stored in API environment and then transferred to microtask queue. Thus in above case cbF function is a promise and is pushed to microtask queue.
 
//but first the gec executes and only after that the cb functions from queues are transferred to the call stack by the event loop. haha if the settimeout is set to 0ms it might still take more time 5-10ms cuz it waits for call stack to be empty and only then can it be pushed for execution.

// 4. Event loop continuously observes call stack and when it is empty it transfers task to call stack.
//this means asynchronous functions and methods have to wait for the call stack to be empty and only then can they be executed.

// 5. Micro task is given priority over callback tasks.

// 6. imp ppoint. all this webAPI env and queues, these come into picture only for asynchronous methods.(those which execute along side main call stack, elsewhere)
//  the synchronous callback functions like what we pass inside map, filter, and reduce aren't registered in the Web API environment. It's just those async callback functions that go through all this.
 
// 7. Too many micro tasks generated can cause Starvation (not giving time to callback tasks to execute).

//JS ENGINE:

// 1. JS runtime environment: contains all elements required to run JS.

 // JS ENGINE contains JS engine, set of API's, callback queue, microtask queue, event loop.

// JS engine is a piece of code.
//js engine takes code as input then executes following process:
// Process includes Parsing ---> Compilation -----> Execution.

// Parsing breaks code into tokens and converts it into AST(Abstract Syntax Tree). after that compilation.

// js is interpreter lang or compiler lang?
// interpreter executes line by line(fast).. compiler first optimises before execution and then executed.
// what does js use?

//js can behave as both depending on engine..
// Modern JS engine follows JIT compilation, it interprets while it optimises code as much as it can. thus best of both worlds.

//after this execution is done.. various elemnts for that are used

//alongside js engine also has call stack, memory heap: space where all the var and funcitons are assigned memory, garbage collector: uses mark n sweep algorithm, optimizations:inlining,copy elision, inline caching

//ignition interpreter and turbofan compiler make code run v fast
//v8 js engg(googles js engine): can research about it

//SET_TIMEOUT_TRUST_ISSUES:

//if main code takes more time than timer expiry.. settimeout can't help at all, the call back function has to wait for call stack to be empty, inturn hampering performance of many async operations.
//thus its adviced to try to never block the main thread. 

//even if the settimeout has 0ms timer, then also it is executed in the end after the main thread is complete exceuting and call stack is emptied. why? well settimeout is asynchronous method thus it comes with its pros n cons.
//usecase: can defer a particular method to execute in the end of the main thread execution. thus it will execute in the end of the whole call stack is executed.

//HIGHER-ORDER FUNCTIONS

//A function which takes another func as an argument or returns a func from it is known as higher order function
//eg:

function x(){
  console.log("Namaste");
}

function y(x){
  x();
}

//function y is a higher order func as it takes x func as argument. x is the callback function. this is only possible cuz functions are first class citizens in js.

//eg: simple area calculation of circles and circumference

const radius = [3,1,2,4];

const calculateArea = function(radius) {
  const output = [];
  for(let i = 0;i<radius.length;i++){
    output.push(Math.PI*radius[i]*radius[i]);
  }
  return output;
};

console.log(calculateArea(radius));

const calculateCircumference = function (radius) {
  const output = [];
  for(let i = 0;i<radius.length;i++){
    output.push(2*Math.PI*radius[i]);
  }
  return output;
};

console.log(calculateCircumference(radius));

//this is repeatitive code a lot. thus we should do somethimg else. optimise our format.
//better to use a generic function, with the logic part extracted out of it

const area = function(radius) {
  return Math.PI*radius*radius;
}

const circumference = function(radius){
  return 2*Math.PI*radius;
}
const diameter = function(radius){
  return 2*radius;
}

const calculate = function(arr, logic) {
  const output = [];
  for(let i =0;i<arr.length;i++){
    output.push(logic(arr[i]))
  }
  return output;
}

console.log(calculate(radius,area));
console.log(calculate(radius,circumference));

//it will give same output.
//this is functional programming..breaking down problem into small problems whcih are independent.

//alsooo
console.log(radius.map(area));
//same as
console.log(calculate(radius,area));

//what we made is our implementation of map. will learn further. calculate function is nothing but map.. takes generic array, iterates over it and applies logic to each.

//fun fact: to call that calculate function like this "radius.calculate", we need to give it a power so that it appears with all the arrays in our code. 
//thus we use somethinf called array.prototype

Array.prototype.calculate = function(logic) { //this is like a polyfill..(search)
  const output = [];
  for(let i =0;i<this.length;i++){
    output.push(logic(this[i]))
  }
  return output;
}

console.log(radius.calculate(area));

//this in the calculate function points to the array which is invoking it, we have radius in this case.(relate to OOPS it makes complete sense. this ptr.)

//MAP,FILTER AND REDUCE

//MAP: used for transformations to an array 
//eg: to double all elements of an array 

const arr = [5,1,3,2,6];
//Double - [10,2,6,4,12];

function double(x){
  return x*2;
}

const output = arr.map(double);

console.log(output);
//eg: for decimal to binary

function binary(x){
  return x.toString(2); //this converts a number to the string of given base (here 2 means binary)
}

const output = arr.map(binary);
//Can also be written as::

const output = arr.map(function binary(x){
  return x.toString(2); 
});

//or arrow function:

const output = arr.map((x) =>  x.toString(2)); //when single line func we can remove braces

//Filter: used when we want to filter the array to obtain those values which follow said conditions.

function isOdd(x){
  return x%2;
}

const output = arr.filter(isOdd);
console.log(outptut);

//Reduce: find or compute one value after iterating through all values of array.
//eg: sum :

const output = arr.reduce(function(acc,curr){
  acc = acc + curr;
  return acc;
},0); 

//2 arguments of reduce function are (a,b), 'a' is function and 'b' is the initial value of accumulator inside the function
//    2 args of function 'a' are (x,y), x is accumulator which is corresponding to the value we are computing or value which is a part of our final output, and y is current which iscorresponding to each element of the array as we iterate through it (arr[i])

//eg 2: find max value in array

const output = arr.reduce(function(acc,curr){
  acc = (acc>curr)?acc:curr
  return acc;
},0); 

//Real life example of smth:

///given:

const users = [
  {firstName: "akshay", lastName: "saini", age:26},
  {firstName: "bono", lastName: "lata", age:26},
  {firstName: "shaily", lastName: "shekhar", age:20},
  {firstName: "bb", lastName: "kabb", age:22},
];

//ques: give list of full names
//what will u use?

//A. map to be used.
 
const output = users.map(x => x.firstName + " " + x.lastName);

//ques: how many ppl have same age should be printed? print all ages and their frequencies

//A. reduce to be used

const output = users.reduce(function(acc,curr){
  if(acc[curr.age]){
    acc[curr.age]++;
  }
  else{
    acc[curr.age] = 1;
  }

  return acc;
},{});
//acc used as dictionary

//OP:
{20:1, 22:1, 26:2}

//Q: print only those entries who have age less than 25
//A: filter

const output = users.filter(x => x.age<25);

//Q: find first name of all ppl aged less than 25
//A: map over previous op
const output = users.filter(x => x.age<25).map(y=>y.firstName);

//how to do it using reduce??

const output = user.reduce(function(acc, curr){
  if (curr.age < 30){
      acc.push(curr.firstName);
  }
  return acc;
}, [ ])
//acc used as array

console.log(output);

//Summary
// 1. map method is used when we want transformation of whole array.
// 2. filter is used when we want to filter the arrar to obtain required value.
// 3. reduce is used when we want to reduce the array to single value eg (max, min, avg, sum, difference etc).
// 4. reduce passes two arguments one function(which includes accumulator and initial value as argument itself) and another initial value of accumulator.

//SEASON2: CALLBACK HELL
//callback functions super imp in handling async operations (helps passing and executing a function elsewhere)

// Two issues while using callbacks

// 1 - Callback hell
// When a function is passed as an argument to another function, it becomes a callback function. This process continues and there are many callbacks inside another's Callback function.
// This grows the code horizontally instead of vertically, also called pyramid of doom. This is very heavy and unmaintainable code. That mechanism is known as callback hell. 
//
// 2 - Inversion of control
// The callback function is passed to another callback, this way we lose the control of our code. We don't know what is happening behind the scene and the program becomes very difficult to maintain. 
// The control of callback function resides in the function which is the higher order function. suppose something is wrong in that function, it affects all callback functions inside it. very unsustainable. cascading callbacks not good.
// That process is called inversion of control. 

//PROMISES:

//eg
const cart = ["shoes","pants","kurta"];
//look at this scenario without promise

createOrder(cart, function (orderId) {
  proceedToPayment(orderId);
});
//not at all good cuz of inversion of control

//instead use PROMISES :-

const promise = createOrder(cart); //createOrder is an async operation.. 
//so before its execution promise var is allocated an empty object with a data field and placeholder 'undefined' {data: undefined} 
//and after async op is completed, it fills this empty object with the returned data and promise will have these orderdetails

//next step

promise.then(function (orderId) {
   proceedToPayment(orderId);
}); // then is a func avail over promise object which is called and executed when the promise object is not empty anymore.

//(can also be written as
createOrder(cart).then(function (orderId) {
   proceedToPayment(orderId);
});

// previously we were passing a callback function to createorder.
// here in promise we are attaching a callback function to our promise object

// promise gives us guarantee that whenever we have data in the promise obj, only then it will execute the callback function and only and only once.

//consider professional promise work

fetch() //this is a api given by browsers to us to make external calls

//see an example:

const GITHUB_API = "https://api.github.com/users/akshaymarch7"

const user = fetch(GITHUB_API);
//now fetch returns us a promise.

//a promise object:

//it contains promiseState, promiseResult, prototype
//promiseResult is the data which is returned from async method which is initally undefined
//promiseState is what state the promise object is currently in. initally when undef is there, state is "pending". once data is returned after due course of time, state is "fulfilled"

//next..
console.log(user); //what will it log here pending or fulfilled?

//it will log pending state.. but after sometime the state will change to fulfilled cuz it will be done fetching data.

user.then(function(data){
  console.log(data);
}) //this logs the json response

//fact: promise has 3 states, fulfilled, pending and rejected
//fact: promise objects are immutable.
//means- user cannot be changed or mutated

//promise: promise object :it is a placeholder for certain period of time until we recieve a value from an asynchronous operation
// also: called a container for a future value
// or: promise is an object represents eventual completion of an asynchronous operation 

//suppose more callbacks are there

createOrder(cart).then(function (orderId) {
  return proceedToPayment(orderId);
})
.then(function (orderId) {
  return showOrderSummary(orderId);
})
.then(function (orderId) {
  return updateWallet(orderId);
});

//this is called promise chain. always write return since, the returned value will be used by the next ".then" in a promise chain
//arrow functions

createOrder(cart).then((orderId) => proceedToPayment(orderId))
.then((orderId) => showOrderSummary(orderId))
.then((orderId) => updateWallet(orderId));

//just different syntax (single lined arrow function directly returns)

//HOW TO CREATE YOUR OWN PROMISE

//EG:
//Consumer side code:
const cart = ["shoes", "pants", "kurta"];

const promise = createOrder(cart);

promise.then(function (orderId){
  proceedToPayment(orderId);
})
.catch(function(err){
  console.log(err.message);
})
/////

//Produce side code:

function createOrder(cart) {
  const pr = new Promise(function(resolve,reject){  //this is how we allocate and create a promise.. resolve and reject are inbuilt args we need to use
    //createOrder
    //validateCart
    //orderId 
    if(!validateCart(cart)) { //this validity is checked by making external calls and queries with the database irl
      const err = new Error("Cart is not valid");
      reject(err); //see its significance? this will now make state of promise as rejected.
    }
    
    //logic for createOrder (now that edge case has been handled for invalid cart)
    const orderId = "12345"; // taking dummy irl it will be fetched from db
    if(orderId){
      resolve(orderId); //promise will be resolved or fulfilled. yay!
    }

  });

  return pr; //since every promise object is returned 
}

//once we call resolve(x) //line 1063
//this data 'x' just goes to the argument of the callback function attached to "then" of the promise obj (line 1016)

//what if validate cart fails?? cosole we have a "Error: Cart is not valid"
//but user cannot see anything on screen. so we need to handle error gracefully
//thus we use "catch" in the consumer side.

//DIVE DEEP TO PROMISE CHAINING

createOrder(cart)
.then(function(orderId) {
  console.log(orderId);
  return orderId; //this returned order id going to be passed to the next "then's call back function".
})
.then(function(orderId){ //arg is same as returned orderId in above function
  return proceedToPayment(orderId);
})
.then(function(paymentInfo){ //paymentInfo is the returned obj from above proceedTopayment which is a returned promise
  console.log(paymentInfo); 
})
//basically return the promise/data at each stage and pass it to the next level of the chain

.catch(function(err){  //this catch is going to check for error in any of the chain levels (cuz its written in the end of the whole chain)
  console.log(err.message);
})

//OTHER ERROR HANDLING LEVEL

createOrder(cart)
.then(function(orderId) {
  console.log(orderId);
  return orderId; //this returned order id going to be passed to the next "then's call back function".
})
.catch(function(err){  //this catch is going to check for error in above chain only (cuz its written after above function only, or attached to above function)
  console.log(err.message);
})
.then(function(orderId){ //arg is same as returned orderId in above function
  return proceedToPayment(orderId);
})
.then(function(paymentInfo){ //paymentInfo is the returned obj from above proceedTopayment which is a returned promise
  console.log(paymentInfo); 
})
//in above case "no matter what happens level 2 and 3 (i.e proceed to payment and payment info) will always be called because no error handling is corresponding to them here"


//proceedtoPayment for eg:

function proceedtoPayment(orderId) {
   return new Promise(function(resolve,reject) {
    resolve("Payment successful");
   });
}

//whole code again 
////////////////////////

const cart = ["shoes", "pants", "kurta"];

const promise = createOrder(cart);

promise.then(function (orderId){
  proceedToPayment(orderId);
})
.catch(function(err){
  console.log(err.message);
})

/////

//Produce side code:

function createOrder(cart) {
  const pr = new Promise(function(resolve,reject){  
    
    if(!validateCart(cart)) { 
      const err = new Error("Cart is not valid");
      reject(err); 
    }
    
    
    const orderId = "12345"; 
    if(orderId){
      resolve(orderId); 
    }

  });

  return pr; 
}

function validateCart (cart){
  return true;
}

createOrder(cart)
.then(function(orderId) {
  console.log(orderId);
  return orderId; 
})
.then(function(orderId){ 
  return proceedToPayment(orderId);
})
.then(function(paymentInfo){ 
  console.log(paymentInfo); 
})
.catch(function(err){ 
  console.log(err.message);
})

function proceedtoPayment(orderId) {
  return new Promise(function(resolve,reject) {
   resolve("Payment successful");
  });
}

//OP:
12345
Payment successfull

//ASYNC AWAIT!

//async: keyword used before a func to create an async func

async function getData() {

}

//async function ALWAYS returns a promise
//2 ways to do that:-

async function getData() {
   return new Promise(...);
}

//OR

async function getData() {
  return "Namaste"; //here the function takes the return value, wraps it in a promise and returns it
}

const data = getData();
console.log(data); 
//OP will be:

Promise {<fulfilled/>: 'Namaste'}  //basically a promise object

 //how to print Namaste on console (extract promiseResult from promise)

 data.then(res => console.log(res));

 //suppose
const p = new Promise((resolve, reject) => {
  resolve("Promise Resolved Value!");
});

async function getData() {
  return p; //this won't be wrapped further in a promise because it is already a promis obj, hence it will be returned as it is.
}

const dataPromise = getData();

dataPromise.then(res => console.log(res));

 //OP: 
 Promise Resolved Value!

 //how to use async along with await.? 
 //A: 1. async and await are used to handle promises. 

 //how we used to handle promises before async await.?

 const p = new Promise((resolve, reject) => {
  resolve("Promise Resolved Value!");
});

function getData() {
  p.then(res => console.log(res)); 
}

getData();

//now using async await

const p = new Promise((resolve, reject) => {
  resolve("Promise Resolved Value!");
});

async function handlePromise() {
   const val = await p; //here await will automatically RESOLVE the promise 'p'
   console.log(val);
}

//imp: await can only be used inside an async function

//ADVANCED EXECUTIONS USING ASYNC AWIT:

const p = new Promise((resolve, reject) => {
  setTimeout(() => {resolve("Promise Resolved Value!");
}, 10000);
}); //now this promise will only be resolved after 10 seconds

function getData() {
  //js engine will not wait for thispromise to be resolved
  p.then(res => console.log(res)); 
  console.log("NAmaste");
}

getData();

//OP:
Namaste
Promise Resolved Value! // after 10 sec
//problem? : 
//what if we want promise to be resolved and only then normal js to execute

//using async func instead of getData funct

async function handlePromise() {
  //js engine will wait for thispromise to be resolved (not really but looks like)
  const val = await p; // program waits here.. the rest of code also waits for this async operation to happen
  console.log("Namaste");
  console.log(val);
}

handlePromise();

//OP:
//blank screen for 10 sec
Namaste
Promise Resolved Value!

//TRICKY EXAMPLE
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {resolve("Promise Resolved Value!");
}, 5000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {resolve("Promise Resolved Value!");
}, 10000);
});

async function handlePromise() {
  console.log("hello wrold!"); //1. first thing this line executes instantly as code runs
   const val = await p1; // 2. await, first check whether p1 is already resolved or not? unresolvd. thus the js engine will "suspend the function handlepromise" handlepromise is removed from call stack (rest of the code apart from this func will execute normally) but here there is nth else apart from this func, thus blank screen as we wait
   console.log("Namaste"); //3. after p1 is resolved, handlepromise is pushed back to the call stack and the rest of func code execute. console logs this text after 5 seconds.
   console.log(val); //4. logs along with Namaste 

   const val2 = await p2; //5. check whether p2 already resolved or not? unresolved. thus suspend function, wait for p2 to resolve (10 sec) push back in call stack and cont execution
   console.log("Namaste 2"); //6. logs after (10sec that took to resolve) func back in call stack (main thread).
   console.log(val2);//7. logs along with above line namaste 2

}

handlePromise();

//OP:
hello world!
//blank screen 5sec
Namaste
Promise Resolved Value!
//blank screen 10 sec
Namaste 2
Promise Resolved Value!

//suppose in val2 we put await p1, output would be

hello world!
//blank screen 5sec
Namaste
Promise Resolved Value!
Namaste 2
Promise Resolved Value!
//why?  first we check wheteher p2 already resolved or not, this one was already resolved so didnt suspend again. SOCOOL

//REAL example of async await:

//run this using dummy html and js and notice the json data on your console!

const API_URL = "https://api.github.com/users/shelobel";

async function handlePromise() {

  const data = await fetch(API_URL);

  // how fetch works
  //1. fetch() function is a promise, which gives a response object
  //2. this response body is a readable stream, to convert it to json u need to do response.json
  //3. this response.json() is again a promise which will give us a jsonValue (which can be further logged) 
  // fetch() => Response.json() => jsonValue (not code but flow)
  // fetch().then(res => res.json()).then(res => consolelog())  (example code)
  
  const jsonValue = await data.json();

  console.log(jsonValue);

}

handlePromise();

//ERROR HANDLING FOR ABOVE EXAMPLE

async function handlePromise() {

  try{ //if api is valid then this is executed
    const data = await fetch(API_URL);
    const jsonValue = await data.json();
    console.log(jsonValue);

  } //if api is invalid then this is executed (customised error handling here)
  catch(err){
    console.log(err);
  }
  
}

handlePromise();

//another way of error handling?

handlePromise().catch((err) => console.log(err)); //we know handlepromise is an async func means async func always returns a promise, so we have a .catch on our promise

//WHAT IS BETTER? ASYNC AWAIT OR THEN,CATCH?

//A. async await is just syntax play, behind the scene same then catch takes place.. async await is better for documentaion and clarity
// try using async await 

////////////////
//PROMISE APIs
////////////////

// [p1,p2,p3]
//  |  |  |
//  3s 1s 2s

//1. Prommise.all()

// takes array of promises as input. tbh it is called iterable.
Promise.all([p1,p2,p3]) //takes 3 parallel api calls and gets result.

//suppose p1 takes 3 sec, p2 takes 1 sec, p3 takes 2s (assume all are successfull)

//promise.all(p1,p2,p3) will return array of results of all these promises [val1,val2,val3] 

//time? all promise will return taking their individual times, but final array of values will wait for ALL OF THEM TO FINISH

//thus array [val1,val2,val3] generates after 3 sec. 


//what if any of these promises get rejected?

//consider scenario of same example
//suppose p2 gets rejected after 1 sec

//then PROMISE.ALL will ALSO BE A FAILURE, it will throw an error. and  the error thrown will be same error returned by p2.
//immedeately as error happened, it ise returned (will not wait for other promises to reject resolve whatever)

//thus after 1 sec OP: Error which was thrown by p2

//what happens to p1 and p3? their api calls fail? no.

//p1 and p3 will accept or reject normally .

//but promise.all gets rejected if ANY of the promises is rejected!! and output is [err(i)] ith promise that got rejected
/////////////////

//2. Promise.allSettled()

Promise.allSettled([p1,p2,p3])

//suppose one of p1,p2,p3  gets rejected, it will STILL wait for other promises to settle and after (max(time taken of a promise)) it will give output
//if success, get val, if failure u get error in array

//suppose p3 fails (i.e after 2 sec we get to know it has failed) .. no worries, we keep waiting fo others to settle and after all are done (3s taken by p1) we present output
[val1,val2,err3];

//safest option among all


////////////////

//3. Promise.race()
 
Promise.race([p1,p2,p3]);

//same example, p2 is done by 1 sec, then the value returned will be of first settled promise

//whichever promise 'settles' first, that is returned

//ans will be (val2)
//what if p2 fails? error will be thrown
//ans will be (err2)
////////////////

//4. Promise.any()

Promise.any([p1,p2,p3]);

//same example, but here it will wait and return the FIRST promise which is SUCCESSFUL

//if p2 is successfull, ans is (val 2)
//if p2 is rejected, promise.any() ignores p2 and waits for next successful promise maybe (val3)
//what if all promises fail? return result will be an "aggregated error"
// it will be an array of all errors
// ans will be [err1,err2,err3]

//how to see aggr error?

Promise.any([p1,p2,p3])
.then((res) => {
  console.log(res);
})
.catch((err)=> {
  console.error(err); // this will give one line saying aggregate error: all promises rejected
  console.log(err.errors); //this line will give you all error objects in an array 
})

//errors[i] gives specific error.

/////////////////

//can check different ways of execution on vid.

//never have uncaught errors, means u have no idea about error and u havent done error handling

//NOTE: all these api return OBJECTS containing returned value, status (fulfilled,reject,etc) and other details of output

// * settle means either resolve or reject (basically complete execution)
// * resolve, success, fulfilled same thing
// * reject, failure, rejected same thing

////////////////
// THIS KEYWORD

//Behavioiur of this keyword in different cases:-

//1. this keyword in global space

        console.log(this);//this keyword in global space always returns the globalObject - window, global

        //output in browser: 
        Window {window: Window, self:Window,..} //on the browser it is giving window because IN BROWSERS GLOBALOBJECT IS WINDOW

        //but javascript runtime env in different spaces, global object can be diff. (in nodejs, in other env etc.)

        //2. this keyword inside a function

        function x() {
          console.log(this);
        }

        x();

        //output:
        Window {window: Window, self:Window,..} //not same as global space op

        //this keyword works differently in strict mode and non-strict mode. All these are non strict mode
        //if u use 
        "use strict";
        //on top of ur file, ur js will run in strict mode.

        //!! thus in strict mode we observe output of this inside function as:-

        undefined

        //therefore inside a function the value of this keyword depends on strict/non-strict mode

        //this substitution: - if the value of this keyword is undefined or null, this will be replaced with globalObject ONLY IN NON-STRICT mode.

        //consider using strict mode now on:-
        "use strict";

        x(); 
        //output: 
        undefined

        //however:
        window.x();
        //output:
        Window {..} //window object

        //thus this keyword value depends on HOW the function is called
            // if the funciton is called WITHOUT any reference its value is undefined
            // if it is called with ref of a calling object, it takes the value of calling object.

// 2. this inside an object's method

        //when a function is created within an object (encapsulated)
        //it is termed as a method (same thing tho)

        const obj = {
          a: 10,
          x: function () {
            console.log(this)
          },
        };

        obj.x();

        //output:
        {a: 10, x: f}

        //this meansssss: whenever you are inside a 'method' the value of this keyword is the object where this method is present.
        //(ofc u should understand this definition as its close to cpp oops)
        console.log(this.a);
        //output will be??
        10
        //GOOD

//3. call apply bind methods (sharing methods)
        //The value of this can be modified using call, apply and bind methods
        // objects can share member methods using .call('objectname')

        const student = {
          name: "Akshay",
          printName: function() {
            console.log(this.name);
          },
        };

        student.printName(); //prints the object containing Akshay name and function printName

        student.printName(this.name);
        //prints output:
        Akshay

        //consider another example-

        const student2 = {
          name: "Deepika",
        };

        student.printName.call(student2); // value fo this = student2
        //this concept is called function borrowing, where we are using a function from an object to help a different object.

        //this is going to print output:
        Deepika



//4. This function inside arrow funcitons

        // arrow functions dont have its OWN this binding associated to it but val of this is the value of enclosing lexical context

        const obj = {
          a: 10,
          //enclosing lexical context
          x: () => {
            console.log(this);
          },
        };

        obj.x(); //value of this will not be the obj but the ENCLOSIN LEXICAL CONTEXT

        //this keyword behaves like it is present in the global space (cuz that lexical context enclosing func is at global level (object is present inside global context))

        //output
        Window {window..}  //window object

        //counter example

        const obj2 = {
          a:20,
          x: function() {
            //enclosing lexical context
            const y = () => {
              console.log(this);
            };
            y();
          },
        };

        obj2.x();

        //output:
        {a: 20, x: f} // obj2 is the value of this now 

        //why?? because the lexical context enclosing the arrow function is the (function x) thus this will behvae exactly how it will behave inside function x!! i.e. for a function, val of this is the object.
        //it is as if the arrow function is not there only!


//5. this keyword inside DOM

        <button onClick="alert(this)">Click me</button>

        //op on clicking:
        [object HTMLButtonElement]

        //this inside DOM elements => reference to the HTML element


//CALL,APPLY and BIND methods

const student = {
  name: "Akshay",
  printName: function() {
    console.log(this.name);
  },
};

student.printName(); //prints the object containing Akshay name and function printName

student.printName(this.name);
//prints output:
Akshay

//consider another example-

const student2 = {
  name: "Deepika",
};

student.printName.call(student2); // value fo this = student2
//this concept is called function borrowing, where we are using a function from an object to help a different object.

//this is going to print output:
Deepika

//however in general sense we dont write functions inside objects:-

const student1 = {
  name: "Akshay",
};

const student2 = {
  name: "Baby",
};

let printName = function() {
  console.log(this.name);
}

printName.call(student1);
//output:
Akshay

printName.call(student2);
//output:
Baby

//suppose function has more arguments?

let printName = function(town,state) {
  console.log(this.name + " hails from " + town + ", " + state);
}

//hence, first argument in call method is always the reference to the object

printName.call(student1,"Durgapur","WB");

//apply method:-
//instead of comma seperated arguments in call, we pass a second argument of the list of those arguments

printName.apply(student1,["Durgapur","WB"]);

//Bind method:-

//Instead of directly calling a method like in call, bind method binds the method (printfullName here) with the object and returns us the copy of that method
//NOTE: it doesnt directly call the function (like prev methods) it jsut keeps a copy which can be invoked later
let printMyName = printName.bind(student2, "Mumbai", "Maharashtra");
printMyName(); //since it is a function after all
//output:

Baby hails from Mumbai, Maharashtra










 
