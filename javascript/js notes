//your go to js notes
//vvv brief
//there is an execution context in js where there are 2 components: memory and code.
//memory aka variable environment stores data in key value pairs
//code component aka thread of execution executes one line at a time (single thread)

//*****js is synchronous single threaded language******

//in js, unlike other languages there are two phases of this execution context
//first (memory creation phase) skimming is done to allocate memory to every element (top to down)
//second (code execution phase) we start main execution (top to down)

// in functions an altogether new ec is created and in phase 1 we allocate mem to parameters as well as variables inside the function
//CODE:
var n = 2;
function square(num) {
  var ans = num*num;
  return ans;
}

var square2 = square(n);
var square4 = square(4);

// first of all global execution context is created
//phase 1:
//line 15 n is allocated undefined
//line 16 square is allocated {.....} whole code inside of it
//line 21 square2 is allocated undefined
//line 22 square4 is allocated undefined
//phase 2:
//line 14 in n value undef replaced with 2
//line 20 (we have function call) 
    //local ec of function created where only code inside func square is dealt with
    //phase 1:
    //line 15 num is allocated undef
    //line 16 ans allocated undef
    //phase 2:
    //line 21 function invoked with arg n and we have n = 2 from gec, hence in lec we replace undef with 2 for num
    //line 17 now ans = num*num = 4 and ans's undef replaced with 4
    //line 18 special keyword ans... now return the control to place where function was invoked now line 21 square2 will get val of ans = 4
    //line 21 in global ec we will now replace square2 with 4 which was returned.
//since function is over, whole lec is deleted now
//line 22 (we have func call)
    //local ec of function created where only code inside func square is dealt with
    //phase 1:
    //line 15 num is allocated undef
    //line 16 ans allocated undef
    //phase 2:
    //line 22 function invoked with arg 4, hence in lec we replace undef with 4 for num
    //line 17 now ans = num*num = 16 and ans's undef replaced with 16
    //line 18 special keyword ans... now return the control to place where function was invoked now line 21 square4 will get val of ans = 16
    //line 22 in global ec we will now replace square4 with 16 which was returned.
//since function is over, whole lec is deleted now
//since whole code complete we will delete gec now

//CALL STACK: it maintains the order of execution of execution contexts.
//in above example, first stack had 
//$
//$->gec
//$->gec->lec(line 21)
//$->gec
//$->gec->lec(line 22)
//$->gec
//$

//HOISTING IN JS:
// 1. Hoisting in JavaScript is a process in which all the Variables, Functions and Class defination are declared BEFORE execution of the code 
// 3. Variables are initialised to UNDEFINED when they are declared and Function defination is stored AS IT IS.
// 4. They are declared in Memory Allocation Phase in the Memory Component of Execution Context, so we can use them even BEFORE they are declared.
// 5. UNDEFINED means Variable has been declared but value is not ASSIGNED but NOT DEFINED means Variables is NOT DECLARED.
// 6. When we assign Variable to a Function definItion(like arrow function), we CAN NOT call this Variable as Function BEFORE declaration as it will behave as Variable with UNDEFINED value.
//take eg:

getName();
console.log(x);

var x = 7;
function getName() {
  console.log("Namaste javascript");
}

//in any other language above code will give error since nothing is defined initially
// but in js op will be:
Namaste javascript
undefined

//why? its because there are two phases of ec! in first phase we allocate memory to all variables and functions
// thus in second phase when code is actually executed.. we do have the elements in our variable environment.
// function executes normally
// however line 71, we dont have x initialsed to anything yet thus it prints its placeholder value i.e. undefined
//wow right?

// just btw 
  console.log(getName)
//this will give output on console:
f getName() {
  console.log("Namaste javascript");
}
//now : 

getName();
console.log(x);
console.log(getName)
  
var x = 7;
function getName() {
  console.log("Namaste javascript");
}

//output will be:
Namaste javascript
undefined
f getName() {
  console.log("Namaste javascript");
}

// it is self explanatory by now (since in first phase line 74, will store getName : {......} code of the entire function in memory)
//EVEN BEFORE CODE STARTS EXECUTING, WE ALREADY ALLOCATE MEMORY TO VARIABLES AND FUNCTIONS, this is called HOISTING

//one more imp thing: arrow function
var getName = () => {
  console.log("Namaste javascript");
}

//js treats arrow functions as variables only. now if we run getName() in the code (before the function definition) where getName is an arrow function, console will give error saying getName is not a funciton
// arrow function is also allocated undefined (cuz treated as var)
//another method shown below also behaves as var
var getName2 = function () {

}

//SHORTEST JS PROGRAM:

// an empty file is still a shortest code as a global execution context is created and sets up memory space

	// • window object is created by the JS engines of the respective browsers when global execution context is created.
	// • whenever an execution context is created a "this" variable is also created.
	// • at the global level "this" points to the global object( window object in case of browsers).
	// • anything that is not inside a function is the "global space".
	// • whenever we create any variables or functions in the "global space", they get attached to the global object( window object in case of browsers).
	
	// so to access the variables/function defined in the global space , 

var a = 10;

	// we can use any of the below:
	// 	console.log(window.a);
	// 	console.log(a);
	// 	console.log(this.a)             //at the global space level, where this points to the window object
//op will be:
10
10
10

//Undefined is like a placeholder for an allocated memory till a value is assigned to a variable.
//undefined !== not defined
//js is a loosely typed or weakly typed language doesnt attach data type to a var forever..
// if u use var x as a string then later can use it as bool, int etc. anything

//SCOPE CHAIN AND LEXICAL ENVIRONMENT
  
// 0) Lexical environment = EC's Local Memory + Reference to Lexical Environment of its parent.

// 1) Lexical Environment of its parent is the scope where a function is physically present or defined. So, suppose a function x(), is defined and invoked in the GEC, when function x()'s EC is pushed in the call stack, it stores a reference to its parent's lexical environment i.e. the GEC's memory.

// 2) Whenever a new Execution Context is pushed in the Call Stack it holds a reference to the Lexical Environment of its parent, i.e. the EC's memory from where it was invoked.

// 3) Global execution context holds reference to null.

// 4)  Javascript engine first looks for the variable/function being accessed in the local scope of the function, and if not found, it keeps on searching the lexical environment of its parent until it finds the variable/function being accessed.

// 5) The mechanism mentioned in point 4 above is called SCOPE CHAIN.

// 6) If the variable accessed is not found in the Scope Chain, then you will get the variable is not defined error in the  browser's console.

//LET AND CONST, TEMPORAL DEAD ZONE

// 1. let and const are hoisted but its memory is allocated at other place than window which cannot be accessed before initialisation. (eg: Script)
// 2. Temporal Dead Zone is the block of code where a variable is inaccessible until variable is declared and initialised a value.
  console.log(a);
  var b = 9;
  let a = 90;
// for a, the TDZ is lines 180 and 181. this on running gives reference error at 180 because, the let a is not allocated in global memory

// 3. window.variable OR this.variable will not give value of variable defined using let or const. because let and const memory is not allocated in global scope but somewhere else
// 4. const variable declaration and initialisation must be done on the same line.
// 5. strictness var<<let<<const
    var //no temporal dead zone, can redeclare and re-initialize, stored in GES
    let //use TDZ, can't re-declare, can re-initialize, stored in separate memory
    const //use TDZ, can't re-declare, can't re-initialize, stored in separate memory
// 6. There are three types of error: [1] referenceError {given where variable does not have memory allocation} [2] typeError {given when we change type that is not supposed to be changed, eg reinitalize const} [3] syntaxError {when proper syntax(way of writing a statement) is not used}.
// 7. Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.
// 8. Initialising variables at the top is good idea, helps shrinks TDZ to zero.

//BLOCK SCOPE AND SHADOWING
//Q) What is block in JavaScript?
// multiple js statements formed in a group enclosed in brackets and it forms a block

//Q) What is need of a block/Grouping?
//JavaScript sometimes expect to run a single statement to run, but we need to run commands with multiple statements which is only possible by block

//write a simple function:
// even empty script is perfectly valid js script, what about empty brackets!!
{
 var a = 10;
 let b = 20;
 const c =30; 
}

//When a js script get hoisted (a Global Execution Context) gets created 'var' listed towards 'Global environment' and other variables 'let' and 'const' declarations go to the 'Block environment' 

//This become especially important when deciding the scope of a particular variable, since b and c are located in 'Block environment' and for a as we know exists in 'Global environment' any statement out of the "Block" can access 'a' ie.  ' Variable in Global environment' and other are not!

//so when we understand the extent of Global and local environment variables and their 'Scopes' == Environment that forms the lexical hierarchy of 'Scopes' and 'Scopes' have Levels like 'Scope inside scope'


 var a = 100;
{
 var a = 10;
 let b = 20;
 const c =30; 
 console.log(a);
 console.log(b);
 console.log(c);
}
 console.log(a);
 console.log(b);
 console.log(c);

//OP:
10
20
30
10
error
//So in block " var a = 10;" influences the global value itself because var is hoisted in global space, hence  console.log(a); >> 10 and outside of the block 'Variable in Global environment' influences value of a hence console.log(a); >> 10

//SHADOWING: basically when a variable of same name is declared inside a scope, it is now relevant within the scope as the locally declared variable. this is called shadowing as it shadows the original outer scope variable.


let a = 20;
{
  let a = 10;
  console.log(a);
}
console.log(a);
//OP:
10
20

//a shadows global a inside the scope.
//(but if it was var, there would be shadowing however, after coming out of scope, the variable will not regain global value as it has been modified by local var cuz they share same memory space.. thus var is not block scoped

//ILLEGAL shadowing:

let a = 200;
{
 var a =20;
}

//as 'var' declaration goes to 'Global environment' and sets in Memory context, it cannot be set using 'Block environment' value Hence:    Uncaught SyntaxError: Identifier 'a' has already been declared
var a = 20;
{
 let a = 25;
}

// this is acceptable as let is block scoped and a is an independent variable allocated in a different space (block space) unlike var which is allocated in global space.

//CLOSURE:
//closure :Function bundled with its lexical environment is known as a closure. 
// a function remembers its outer environment as it stores a reference of its outer env even if it is executed elsewhere. outer env includes variables declared outside the function be it let, var ,const anyting, or a parameter passed in an outer nested function..
// Whenever function is returned, even if its vanished in execution context but still it remembers the reference it was pointing to. 
// Its not just that function alone it returns but the entire closure and that's where it becomes interesting !! 

// in js functions can be assigned to variables, fn can be passed as parameters, fn can be returned from other fn as well.

function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 return y;
}
var z = x(); // after this line executes, x will be gone (x's lec will be deleted) and variable z will be assigned return val of x() (basically z stores closure of return val of x i.e function "y" and it still remembers the reference it was pointing to ) in a way z is also a function 
console.log(z); // here the content of z is printed. what is z? simply the returned value of x() i.e. function y. so output will be the code of function y
z(); //(interesting) we call z and it holds function y which has a reference to 'a' thus z stores the closure of y 

//OP:
f y(){
  console.log(a);
}
7 //because z contains closure of y which means memory and the lexical env of y hence a is preserved
//also
function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 return y;
}

//same as

function x(){
 var a = 7;
 return function y(){
    console.log(a);
  }
}

//Q: what will be op?

function x(){
 var a = 7;
 function y(){
    console.log(a);
  }
 a = 100;
 return y;
}
var z = x();
z();

//OP:
100
// calling z means calling y (as z = ret val of x = y). now y does not store the "value" of a but the "reference" of a. 
// hence when we modify a as 100, we have affected the reference in the lexical env. thus we get op as 100

//Q: what will be op?

function z() {
 var b = 900;
 function x(){
    var a = 7;
    function y(){
       console.log(a,b); // when we are here during execution, fn y stores closure of x which inturn stores closure of z. thus we have both references a and b in hand.
     }
    y();
   }
 x();
}
z();

//OP: 7 900

//SET-TIMEOUT
//1. setTimeout stores the function in a different place and attached a timer to it, when the timer is finished it rejoins the call stack and executed. (while executing in diff place, it obv has the closure of all variables which share scope with it)
//2. Without closure the var reference gives the latest value as it does not retain the original value but rather has the reference so any update in value after timeout will be shown.
//3. If we use let/const because they have block scope, every time a new copy of variable is attached, thus this can be done without closure.

function x(){
 var i = 1;
    setTimeout(function() {
      console.log(i);
     }, 3000); // means timeout of 3 seconds or 3000 mili sec
    console.log("hello");
}
x();

//OP:
hello
1 //after 3 sec
//note: see that hello didnt print after 3 sec as it might appear from code. this is cuz settimeout executes somewhere else, storing the closure in this case the reference to i,. the rest of code executes normally, and when settimeout is done executing, it joins back in the call stack. 
// thus hello prints as usual but 1 is printed after a timeout of 3 seconds.

// explanation of pt 2 with situation: say u have to print numbers 1 2 3 4 5 one after other in 1 sec gap

function x(){
 for(var i = 1;i<=5;i++) {
     setTimeout(function() {
       console.log(i);
      }, i*1000); 
   }
 console.log("hello");
}
x();

//OP:
hello
6
6
6
6
6
//after 1 sec gap each

//.....wHATTTTTT 
//hehe this is cuz setTimeout has the closure of its lexical env as in it still references  to 'i'. now loop will run in usual pace and i will quickly increment to 6. but in these seperate timeouts of 1000,2000,3000,4000,5000 ms we have i referencing to same memory location. thus they all will now have 6.
//upon printing also they all print 6 as and when their timer exhausts.

//fixing the problem by "let" as let as block scope. thus with each loop iteration, each function has a new copy of i which has independent space in their scope.

function x(){
 for(let i = 1;i<=5;i++) {
     setTimeout(function() {
       console.log(i);
      }, i*1000); 
   }
 console.log("hello");
}
x();

//OP:
hello
1
2
3
4
5

//what if u cant use let?

//u can use a function embedded inside our loop and pass i as a parameter. this will always create new copy of i 

function x(){
 for(var i = 1;i<=5;i++) {
   function close(x) {
      setTimeout(function() {
        console.log(x);
       }, x*1000); 
    }
   close(i);
  }

 console.log("hello");
}
x();

//OP:
hello
1
2
3
4
5

//code writing in js : random snippet

function Counter()
{
	var count = 0;

	this.incrementCounter = function(){
	  count++;
	  console.log(count);
	}
	
	this.decrementCounter = function(){
	  count--;
	  console.log(count);
	}
}

var counter1 = new Counter();

counter1.incrementCounter();

//*data hiding of variables like count in this case.. decrementCOunter and incrementCOunter are function constructors.. kinda see the OOD pattern here.

//Disadvantage of closure:
//overconsumption of memory, and sometimes variables not grabage collected after program is over and if not handles properly leads to memory leaks
//garbage collection: program in js engine which frees up the unutilised memory
//1. An inner function can be directly called using two parenthesis ()().
//2. Even parameters can be passed this way (Remember that the function needs to be returned to do this)
//3. Closures can also be used for data hiding and encapsulation. So other code cannot access this value.
//4. Unused variables are automatically deleted in High Level Programming language by garbage collector. Closures allocate a lot of memory which cannot be deleted so this acts as a disadvantage.
//5. Some browsers now have smart garbage collectors that automatically deletes variables that are not used outside closures.

// FUNCTIONS!
// 1.  What is Function Statement/Function Decleration ?
// A.  A normal function that we create using Naming convention. & By this we can do the Hoisting.
//      For Ex  -  

      function xyz(){
        console.log("Function Statement");
   }

// 2.  What is Function Expression ?
// A.  When we assign a function into a variable that is Function Expression. & We can not do Hoisting by this becz it acts like variable.
//       For Ex - 
var a = function(){
              console.log("Function Expression");
      }

//MAJOR DIFF BETWEEN func exp and func statement is that func statement will be hoisted even before execution. so calling it before exec is no prob.
//BUT func exp behaves like a variable.. initially allocated undefined. thus calling it before its definition will give typeError cuz its a var.

// 3.  What is Anonymous Function ?
// A.  A Function without the name is known as Anonymous Function. & It is used in a place where function are treated as value.
//       For Ex - 

function ()  {
   
 }
//normally it is invalid syntax but it comes in use when func is used as value


// 4.  What is Named Function Expression ?
// A.  A function with a name is known as Named Function Expression.
//       For Ex - 
var a = function xyx(){
            console.log("Names Function Expression");
      }
//NOTE: here
xyz();
// above will give reference error saying xyz not defined. why? 
// because xyz is not in global scope, it is within the local scope of var a thus we cannot access it from outside.


// 5.  Difference b/w Parameters and Arguments ?
// A.  When we creating a function  & put some variabels in this ( ) that is our Parameters.
//      For Ex - 
function ab( param1, param2 ){
        console.log("..");
}
//        & When we call this function & pass a variabel in this ( ) that is our Arguments
//        For Ex - 
ab( 4, 5 );


// 6.  What is First Class Function Or First class citizens?

// A.   The Ability of use function as value,

// *     Can be passed as an Argument,
//eg:

var b = function(param){
  console.log(param);
} 

   //EITHER
b(function(){
  console.log("hi");
});
   //OR
function xyz(){
  console.log("hi");
}

b(xyz)
   //will give

//OP:
f (){
  console.log("hi");
}

// *     Can be executed inside a closured function &
// *     Can be taken as return form.
//       For Ex - 
var b = function(param){
        return function xyz(){
                console.log(" F C F ");
        }
} 

console.log(b());

//OP:
function xyz(){
  console.log(" F C F ");
}


// 7. Function are heart of JS. They are called first class citizens or first class functions because they have the ability to be stored in the variables, passed as parameters and arguments. They can also be returned in the function.

//CALLBACK FUNCTIONS:
// 1. Function that is passed on as argument to another function is called callback function.
function x(){

}

x(function y(){

})
//y is the callback function

//consider:

setTimeout(function() {
  console.log("timer");
},5000); 

function x(y){
   console.log("x");
   y();
}

x(function y(){
  console.log("y");
})
//OP:
x//immediate
y//immediate
timer//after 5 secs
// 2. setTimeout helps us perform asynchronous operation(timer ticking elsewhere while rest of the code executes normally doesnt get blocked) evn tho js is single threaded synch lang as it only has one main thread and one call stack.
// 3. Event listeners can also invoke closures with scope.

document.getElementById("clickMe").addEventListener("click",function xyz(){
  console.log("button clicked");  //this right here is a function callback to xyz. and it will be pushed to the call stack everytime the eventlistener is executed. 
});

//how to show number of times clicked.
//use closure by wrapping inside a function
 
function attachEventListener() {
  let count = 0;

  document.getElementById("clickMe").addEventListener("click",function xyz(){
    console.log("button clicked",++count);  //this right here is a function callback to xyz. and it will be pushed to the call stack everytime the eventlistener is executed. 
  });

}

attachEventListener();

// 4. Event listeners consume a lot of memory which can potentially slow down the website therefore it is good practice to remove if it is not used.

//EVENT LOOOOOOOOP

// 1. Browser has superpowers that are lent to JS engine to execute some tasks, these superpowers include "web API's" such as console, location, DOM API, setTimeout, fetch, local storage.
// 2. Callback functions and event handers are first stored in Web API environment and then transferred to callback queue.

//eg:

console.log("start");

setTimeout(function cb() {
  console.log("Callback");
},5000);

console.log("End");

//first gec pushed to call stack start is printed..
//settimeout executes, call back function cb is stored in a Web API environment for the time being and timer starts running.
//meantime, end is printed.. gec is over so gec is pushed out call stack is empty
// now timer still running and hits 0 but now what? we need call back function to go to call stack.. we cant do it just like that

//concept of event loop and callback queue arrives.

//cb function is pushed to callback queue from the webapi env. 
//EVENT loop is like a gatekeeper, who keeps checking whether the callback queue is empty or not.. and if not, it pushes the func to call stack. then the call stack quickly executes cb function.. CAllback is printed.. cb is popped out of the stack. call back que empty. all over

//eg with eventlistener:

console.log("Start");

document.getElementById("btn").addEventListener("click", function cb(){
  console.log("callback");
}); //basically whenever we see addEventListener, it registers thr callback function(here cb) in the webAPI's environment and attaches a "click" evevnt to it

console.log("end");

//the callback function with the event is in the webapi env and is forever waiting for event to occur and then the func will be pushed to cb queue and then the event loop will push it to the stack for execution. thus eventlisteners are very heavy.

//There is one more queue called microstask queue. Event loop gives priority to microtask queue as compared to callback queue or task q.

//eg: 

console.log("Start");

setTimeout(function cb() {
  console.log("Callback settimeout");
},5000);

fetch("https://api.netflix.com").then(function cbF() {
  console.log("CB Netflix");
}); //will study later.. but fetch function returns a promise. fetch function goes and fetches the api call and returns the response after which 'then' is excecuted in this line

console.log("end");

// 3. Promises and mutation observer are stored in API environment and then transferred to microtask queue. Thus in above case cbF function is a promise and is pushed to microtask queue.
 
//but first the gec executes and only after that the cb functions from queues are transferred to the call stack by the event loop. haha if the settimeout is set to 0ms it might still take more time 5-10ms cuz it waits for call stack to be empty and only then can it be pushed for execution.

// 4. Event loop continuously observes call stack and when it is empty it transfers task to call stack.
//this means asynchronous functions and methods have to wait for the call stack to be empty and only then can they be executed.

// 5. Micro task is given priority over callback tasks.

// 6. imp ppoint. all this webAPI env and queues, these come into picture only for asynchronous methods.(those which execute along side main call stack, elsewhere)
//  the synchronous callback functions like what we pass inside map, filter, and reduce aren't registered in the Web API environment. It's just those async callback functions that go through all this.
 
// 7. Too many micro tasks generated can cause Starvation (not giving time to callback tasks to execute).

//JS ENGINE:

// 1. JS runtime environment: contains all elements required to run JS.

 // JS ENGINE contains JS engine, set of API's, callback queue, microtask queue, event loop.

// JS engine is a piece of code.
//js engine takes code as input then executes following process:
// Process includes Parsing ---> Compilation -----> Execution.

// Parsing breaks code into tokens and converts it into AST(Abstract Syntax Tree). after that compilation.

// js is interpreter lang or compiler lang?
// interpreter executes line by line(fast).. compiler first optimises before execution and then executed.
// what does js use?

//js can behave as both depending on engine..
// Modern JS engine follows JIT compilation, it interprets while it optimises code as much as it can. thus best of both worlds.

//after this execution is done.. various elemnts for that are used

//alongside js engine also has call stack, memory heap: space where all the var and funcitons are assigned memory, garbage collector: uses mark n sweep algorithm, optimizations:inlining,copy elision, inline caching

//ignition interpreter and turbofan compiler make code run v fast
//v8 js engg(googles js engine): can research about it

//SET_TIMEOUT_TRUST_ISSUES:

//if main code takes more time than timer expiry.. settimeout can't help at all, the call back function has to wait for call stack to be empty, inturn hampering performance of many async operations.
//thus its adviced to try to never block the main thread. 

//even if the settimeout has 0ms timer, then also it is executed in the end after the main thread is complete exceuting and call stack is emptied. why? well settimeout is asynchronous method thus it comes with its pros n cons.
//usecase: can defer a particular method to execute in the end of the main thread execution. thus it will execute in the end of the whole call stack is executed.

//HIGHER-ORDER FUNCTIONS

//A function which takes another func as an argument or returns a func from it is known as higher order function
//eg:

function x(){
  console.log("Namaste");
}

function y(x){
  x();
}

//function y is a higher order func as it takes x func as argument. x is the callback function. this is only possible cuz functions are first class citizens in js.

//eg: simple area calculation of circles and circumference

const radius = [3,1,2,4];

const calculateArea = function(radius) {
  const output = [];
  for(let i = 0;i<radius.length;i++){
    output.push(Math.PI*radius[i]*radius[i]);
  }
  return output;
};

console.log(calculateArea(radius));

const calculateCircumference = function (radius) {
  const output = [];
  for(let i = 0;i<radius.length;i++){
    output.push(2*Math.PI*radius[i]);
  }
  return output;
};

console.log(calculateCircumference(radius));

//this is repeatitive code a lot. thus we should do somethimg else. optimise our format.
//better to use a generic function, with the logic part extracted out of it

const area = function(radius) {
  return Math.PI*radius*radius;
}

const circumference = function(radius){
  return 2*Math.PI*radius;
}
const diameter = function(radius){
  return 2*radius;
}

const calculate = function(arr, logic) {
  const output = [];
  for(let i =0;i<arr.length;i++){
    output.push(logic(arr[i]))
  }
  return output;
}

console.log(calculate(radius,area));
console.log(calculate(radius,circumference));

//it will give same output.
//this is functional programming..breaking down problem into small problems whcih are independent.

//alsooo
console.log(radius.map(area));
//same as
console.log(calculate(radius,area));

//what we made is our implementation of map. will learn further. calculate function is nothing but map.. takes generic array, iterates over it and applies logic to each.

//fun fact: to call that calculate function like this "radius.calculate", we need to give it a power so that it appears with all the arrays in our code. 
//thus we use somethinf called array.prototype

Array.prototype.calculate = function(logic) { //this is like a polyfill..(search)
  const output = [];
  for(let i =0;i<this.length;i++){
    output.push(logic(this[i]))
  }
  return output;
}

console.log(radius.calculate(area));

//this in the calculate function points to the array which is invoking it, we have radius in this case.(relate to OOPS it makes complete sense. this ptr.)

//MAP,FILTER AND REDUCE

//MAP: used for transformations to an array 
//eg: to double all elements of an array 

const arr = [5,1,3,2,6];
//Double - [10,2,6,4,12];

function double(x){
  return x*2;
}

const output = arr.map(double);

console.log(output);
//eg: for decimal to binary

function binary(x){
  return x.toString(2); //this converts a number to the string of given base (here 2 means binary)
}

const output = arr.map(binary);
//Can also be written as::

const output = arr.map(function binary(x){
  return x.toString(2); 
});

//or arrow function:

const output = arr.map((x) =>  x.toString(2)); //when single line func we can remove braces



// 1. map method is used when we want transformation of whole array.
// 2. filter is used when we want to filter the arrar to obtain required value.
// 3. reduce is used when we want to reduce the array to single value eg (max, min, avg, sum, difference etc).
// 4. reduce passes two arguments one function(which includes accumulator and initial value as argument itself) and another initial value of accumulator.
// 5. Homework:

const output = user.reduce(function(acc, curr){
    if (curr.age < 30){
        acc.push(curr.firstName);
    }
    return acc;
}, [ ])

console.log(output);
